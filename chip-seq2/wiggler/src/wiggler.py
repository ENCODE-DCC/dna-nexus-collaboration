#!/usr/bin/env python
# wiggler 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import subprocess
import multiprocessing
import re

import dxpy

MCR_LIBRARY_PATHS = '''{MCRROOT}/runtime/glnxa64
{MCRROOT}/bin/glnxa64
{MCRROOT}/sys/os/glnxa64
{MCRJRE}/native_threads
{MCRJRE}/server
{MCRJRE}/
'''

MCR_LIBRARY_CONF_FILENAME = 'mcr.conf'

def check_call_debug(cmd):
    print cmd
    subprocess.check_call(cmd, shell=True)

def get_memory(suffix='M'):
    if suffix == 'K':
        shift = 1
    elif suffix == 'M':
        shift = 1 << 10
    elif suffix == 'G':
        shift = 1 << 20
    else:
        raise dxpy.DXError('Unknown memory suffix {0}.  Please choose from K, M, or G.'.format(suffix))

    # Calc amount of memory available for gatk and Picard.
    total_mem = re.findall('^MemTotal:[\s]*([0-9]*) kB',
                           open('/proc/meminfo').read())
    if(len(total_mem) != 1):
        raise dxpy.DXError('Problem reading system memory from /proc/meminfo')
    return float(total_mem[0]) / shift

def download_and_gunzip_file(input_file, skip_decompress=False):
    input_file = dxpy.DXFile(input_file)
    input_filename = input_file.describe()['name']
    ofn = input_filename

    cmd = 'dx download ' + input_file.get_id() + ' -o '
    if input_filename.endswith('.tar.gz'):
        cmd += '- | tar -zxvf - > tar_output_'
        ofn = ofn.replace('.tar.gz', '')
    elif (os.path.splitext(input_filename)[-1] == '.gz') and not skip_decompress:
        cmd += '- | gunzip > '
        ofn = os.path.splitext(ofn)[0]
    cmd += ofn
    print cmd
    subprocess.check_call(cmd, shell=True)

    return ofn

def download_dx_files(dx_files, skip_decompress=False):
    pool = multiprocessing.Pool()
    results = []
    for dx_file in dx_files:
        results += [pool.apply_async(download_and_gunzip_file, args=(dx_file, skip_decompress))]
    pool.close()
    pool.join()

    # 10 seconds is kind of ridiculous considering the value should be ready
    # immediately, but I'd hate to get done downloading a huge file and
    # then error out because the value took a little long to get to me.  But
    # really, this should never happen.
    return [r.get(timeout=10) for r in results]

def install_mcr():
    cmd = 'sudo chmod 775 /MCR2010b.bin'
    print cmd
    subprocess.check_call(cmd, shell=True)

    cmd = 'sudo /MCR2010b.bin -silent '
    check_call_debug(cmd)

    os.environ['MCRROOT'] = '/opt/MATLAB/MATLAB_Compiler_Runtime/v714'
    os.environ['MCRJRE'] = '/opt/MATLAB/MATLAB_Compiler_Runtime/v714/sys/java/jre/glnxa64/jre/lib/amd64'
    os.environ['XAPPLRESDIR'] = '/opt/MATLAB/MATLAB_Compiler_Runtime/v714/X11/app-defaults'
    LD_PATH_TXT = MCR_LIBRARY_PATHS.format(MCRROOT=os.environ['MCRROOT'],
                                           MCRJRE=os.environ['MCRJRE'])
    os.environ["LD_LIBRARY_PATH"] = ':'.join(LD_PATH_TXT.split())
    with open(MCR_LIBRARY_CONF_FILENAME, 'w') as fh:
        fh.write(LD_PATH_TXT)

    cmd = 'sudo cp {0} /etc/ld.so.conf.d/.'.format(MCR_LIBRARY_CONF_FILENAME)
    check_call_debug(cmd)

    cmd = 'sudo ldconfig '
    check_call_debug(cmd)

@dxpy.entry_point('main')
def main(**job_inputs):
    install_mcr()

    if 'frag_len' in job_inputs:
        assert(len(job_inputs['frag_len']) == len(job_inputs['input_bams']))

    downloaded_files = download_dx_files(job_inputs['input_bams'] +
                                         [job_inputs['chr_fastas']] +
                                         [job_inputs['mappability_files']], True)
    input_bams = downloaded_files[0:-2]
    chr_directory = downloaded_files[-2]
    mappability_directory = downloaded_files[-1]
    ofn = os.path.commonprefix(input_bams) + '.' + job_inputs['output_format']

    if mappability_directory.find('female') >= 0:
        cmd = 'rm {0}/chrY*'.format(chr_directory)
        check_call_debug(cmd)

    # Save 10% of the memory for overhead.
    mem = get_memory('G') * 0.9

    cmd = 'alias awk=gawk\n'
    cmd += '/align2rawsignal/bin/align2rawsignal '
    cmd += ' '.join(['-i=' + bam for bam in input_bams]) + ' '
    cmd += '-s=' + chr_directory + ' '
    cmd += '-u=' + mappability_directory + ' '
    cmd += '-o=' + ofn + ' '
    cmd += '-of=' + job_inputs['output_format'] + ' '
    cmd += '-mm={0}'.format(mem) + ' '
    if 'frag_len' in job_inputs:
        cmd += ' '.join(['-l={0}'.format(fl) for fl in job_inputs['frag_len']]) + ' '
    if 'smoothing_window' in job_inputs:
        cmd += '-w={0}'.format(job_inputs['smoothing_window']) + ' '
    if 'smoothing_kernel' in job_inputs:
        cmd += '-k={0}'.format(job_inputs['smoothing_kernel']) + ' '

    check_call_debug(cmd)

    output_file = dxpy.upload_local_file(ofn)

    output = {'output_file': output_file}

    return output

dxpy.run()
